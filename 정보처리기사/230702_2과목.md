# 230702_2과목

### 문제풀이

- 22년 2회차

- 22년 1회차

- 21년 3회차

- 21년 2회차

- 21년 1회차

---

### 개념 정리

- 구현 단계 작업 절차
  
  - 코딩 계획 → 코딩 → 컴파일 → 코드 테스트

- 워크스루
  
  - 요구사항 명세서 작성자 포함
  - 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테케 등에 적용가능
  - 복잡한 알고리즘 등을 이해하려할 때 유용
  - 단순한 테케로 프로덕트를 수행해보는 것

- 인스펙션
  
  - 요구사항 명세서 작성자 제외
  - 계획 → 사전교육 → 준비 → 인스펙션 회의 → 수정 → 후속조치

- 코드 인스펙션
  
  - 프로그램을 수행하는 대신에 읽어보고, 눈으로 확인하는 방법
  - 코드 품질 향상 기법
  - 정적 테스트
  - 결함과 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질이슈도 검사

- 소프트웨어 테스트 기본원칙
  
  - 살충제 패러독스 : 똑같은 테케로는 새로운 결함 발견할 수 없다 (버그에게 면역력이 생겨버려~) → 테케 주기적으로 점검 및 개선할 것!
  - 오류 부재의 궤변 : 사용자의 요구사항을 만족하지 못하면 오류 제거해도 품질 높은거 아님 ㅡㅡ

- 테스트 데이터를 찾아내는 방법
  
  - 자료 흐름도
  - 입력 도메인 분석
  - 랜덤 테스트

- 테스트 케이스
  
  - 테케 실행이 통과되었는지 판단하는 기준을 **테스트 오라클**이라 한다.

- 목적에 따른 테스트 분류
  
  - 강도 테스트 : 과다 정보량을 부과하여 과부하시에도 시스템이 정상작동하는지 확인
  - 회복 테스트 : 고의로 실패를 유도하고 정상적으로 복귀하는지 테스트
  - 성능 테스트 : 이벤트에 응답하는 시간, 업무량, 반응속도 등을 테스트
  - 안전 테스트 : 불법 침투를 잘 막아내는지 테스트

- 인수검사 기법
  
  - 알파 테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 테스트
  - 베타 테스트 : 필드 테스팅. 개발자 없이 고객의 사용환경에 소프트웨어를 설치하여 테스트

- 통합 테스트
  
  - 시스템을 구성하는 모듈의 결합을 테스트
  - 빠르게 하려면 → 하향식이 유리
  
  하향식 통합 테스트
  
  - 넓이 우선 통합법, 깊이 우선 통합법사용
  
  상향식 통합 테스트
  
  - 프로그램의 최하단에 있는 모듈을 먼저 구현하고 테스트한다.

- 테스트 드라이버
  
  - 필요 데이터를 인자를 통해 넘겨주고, 수행 결과를 보여준다.
  - 상향식 테스트
  - 시험 대상 모듈을 호출하는 간이 소프트웨어

- 테스트 스텁 (하스)
  
  - 인자를 통해 받은 값으로 수행한 후, 그 결과를 테스트할 모듈에 넘겨준다.
  - 하향식 테스트
  - 테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.

- 단위 테스트
  
  - 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행
  - 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.

- 화이트박스 테스트
  
  - 논리흐름도 이용
  - 동적 테스트
  - 테케 선택을 위해 검증기준을 정함
  - 기초 경로 검사, 조건 검사, 루프 검사, 데이터 흐름 검사

- 블랙박스 테스트
  
  - 프로그램의 구조를 고려하지 않음
  - 경계값 분석

- 단위 테스트 도구
  
  - CppUnit : C++ 단위테스트 도구
  - JUnit : Java 단위테스트 도구
  - HttpUnit : 웹브라우저 없이 웹 사이트 테스트 수행 도구

- 검증 vs 확인
  
  - 검증 : 요구사항에 잘 부합하나?
  - 확인 : 고객의 의도에 따라 구현되었나?

- 인터페이스 구현 검증 도구
  
  - STAF, watir, xUnit

- Fault vs Mistake
  
  - Fault : 소프트웨어가 설계와 다르게 동작. 오류나 작동실패의 원인
  - Mistake : 사람이 잘못한거

- 소프트웨어 품질 목표
  
  - Portability : 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있다
  - Efficiency : 최소의 작업으로 기능 수행가능
  - Usability : 소프트웨어를 쉽게 사용할 수 있다.
  - Correctness : 사용자의 요구사항을 충족한다.

- 소프트웨어 버전 관리 항목
  
  - import : 아무것도 없는 저장소에 처음으로 파일 복사
  - Check-out : 저장소에서 파일 받아옴
  - Check-in : 파일 수정하여 저장소 갱신
  - Commit : 체크인 할때 충돌을 알리고 diff로 수정 후 갱신 완료

- DRM
  
  - 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자 등이 사용할 수 있는 접근 제어 기술을 의미한다.
  - 디지털 미디어의 생명 주기 동안 발생하는 사용권한 관리, 과금, 유통 단계를 관리하는 기술
  - 키관리, 암호화, 크랙방지
  - 클리어링 하우스 : 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여하는 시스템
  - 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능

- 크랙
  
  불법적인 방법으로 소프트웨어에 적용된 저작권 보호 기술을 해제 및 무단 사용할 수 있도록 하는 기술이나 도구

- 위험 모니터링
  
  - 위험 요소 징후들을 계속적으로 인지하는 것

- R어쩌구
  
  - RCS (Revision Control System) : 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구
  - RTS (Reliable Transfer Service) : 신뢰성이 보장된 데이터 전송 서비스 프로토콜
  - RPC (Remote Procedure Call) : 다른 주소 공간의 컴퓨터에서 실행중인 프로시저를 호출
  - RVS (Relative Version System) : 파일의 상대적 버전 관리

- 형상관리
  
  - 소프트웨어의 변경사항을 관리하는 활동
  - 유지보수 뿐만 아니라 개발 단계에도 적용가능
  - 소프트웨어 개발 전체비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증
  - 형상관리의 기능 중 하나는 버전 제어 기술
  - 형상관리 도구로는 GIT, CSV, SVN 등

- 정형 기술 검토 (FTR)
  
  - 의제를 제한한다.
  - 논쟁과 반박을 제한한다.
  - 문제 영역을 명확히 표현한다.
  - 참가자의 수를 제한한다.

- 소프트웨어 재공학
  
  - Analysis : 기존 소프트웨어를 분석하여 재공학 대상을 선정
  - Restructuring : 기존 소프트웨어를 향상시키기 위해 코드를 재구성
  - Reverse Engineering : 기존 소프트웨어를 분석하여 소스코드를 얻어냄
  - Migration : 기존 소프트웨어를 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업

- 소프트웨어 패키징
  
  - 패키징은 소비자 중심으로 진행한다.
  - 신규 및 변경 개발소스를 식별하고 이를 모듈화하여 사용제품으로 패키징한다.
  - 고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.
  - 범용 환경에서 사용가능하도록 일반적인 배포 형태로 패키징된다.

- NS Chart
  
  - 논리의 기술에 중점을 두고 도형을 이용한 표현 방법
  - 이해하기 쉽고 코드 변환이 용이하다.
  - 연속, 선택, 반복 등의 제어 논리 구조를 표현
  - 화살표를 사용하지 않는다.

- 소프트웨어 품질 관련 국제표준 ISO/IEC 25000
  
  - 소프트웨어 품질평가 통합모델 표준
  
  - SQuaRE라고도 한다.
  
  - 9126 + 14598 + 12119 통합
  
  - 2500n : 개요 및 품질관리
  
  - 2501n : 품질모델
  
  - 2502n : 품질측정
  
  - 2503n : 품질요구
  
  - 2504n : 품질평가
  
  - 2505n : 확장분야

- 제품 소프트웨어의 사용자 매뉴얼 작성절차
  
  - 작성 지침 정의
  - 사용 설명서 구성 요소 정의
  - 구성 요소별 내용 작성
  - 사용 설명서 검토
  - 사용 설명서

- EAI 구축 유형
  
  - Point-to-Point : 애플리케이션을 1:1로 연결
  - Hub & Spoke : 허브를 통해 데이터를 주고받는 중앙집중형
  - Message Bus : 애플리케이션 사이에 미들웨어를 두어 처리
  - Hybrid : 그룹 내에서는 H&S방식, 그룹 간에는 Message Bus방식 사용

- 해싱 함수
  
  - 제곱법
  - 숫자분석법
  - 제산법
  - 기수 변환법

- 알고리즘
  
  - 선형 검색 : 처음부터 끝까지 하나씩 비교하며 원하는 값을 찾는 검색
  - 이진 검색 : 검색 수행 전 반드시 데이터 집합이 정렬되어 있어야함.

- 트리 순회
  
  - 전위 순회 : root → L → R
  - 중위 순회 : L → root → R
  - 후위 순회 : L → R → root

- 트리 검색 시간복잡도
  
  - 이진 트리 : O(n)
  - AVL 트리 : O(log n)
  - 2-3 트리 : O(log 3n)
  - 레드-블랙 트리 : O(log n)

- 정렬
  
  - Selection Sort : 최소값 찾음 → 맨 앞 값과 교환하며 정렬 O(n^2)
  - Bubble Sort : 좌우 비교해서 큰 값을 오른쪽으로 O(n^2)
  - Insert Sort : 한 값을 그 앞 모든 값과 비교하여 삽입할 자리를 찾으며 정렬 O(n^2)
  - Quick Sort : 분할 정복 알고리즘의하나, 피벗을 기준으로 두 부분으로 분할 → 합치며 정렬 O(n^2)
  - Heap Sort : 정렬할 레코드들로 힙(완전 이진트리)을 구성 → 가장 큰 키를 갖는 루트노드를 제거하며 정렬 O(nlog2n)
  - Merge Sort : O(nlog2n)
